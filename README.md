
# Pseudocode Compiler in Lean 4 

**Status**: âœ… Compiles & runs  
**Command**: `lake build && lake exe pseudoc test.pseudo`
---

## Quick Start

Install Lean4 to compile, run the test file (test.pseudo) which contains some sample pseudo-code you should see this output if everything works (feel free to submit a PR if it does not)

Input: set x := 5; while x > 0 do ...
âœ“ PseudoC parsed successfully
AST: [While (> x 0) [Print x, Set x (x - 1)]]

# PseudoC - Practical Pseudocode Compiler 


` Proto-framework for universal verified compilation or in laymens terms it's the Pseudo-idea for the pseudocode for the pseudo_c compiler`

The inspiration for this project is to answer a couple questions

1. Is it possible to use pseudo code to teach algorithms and CS to students and have a tool that will generate executable multi-paradigm code?
2. Is it theoretically possible to boostrap a pseudocode compiler IN psueodcode?
3. Once the pseudocode compiler is built, is it possible to use it to answer reesearch questions aroun grammar agnostic termination?

## ðŸŽ“ Autoformalization Bootstrap** (Boostrap.lean)

**`Bootstrap.lean`** 

Bootstrap.lean defines a pure Lean 4 theorem proving that a bootstrapped pseudocompiler (BootstrappedCompiler) has identical semantics to the original. Lean verifies âŸ¦BootstrappedâŸ§ â‰¡ âŸ¦OriginalâŸ§ through structural equivalence. Run lake build and lake exe pseudoc test.pseudo uses the theorem-extracted verified compiler.

No external dependencies. Pure dependent types + theorem extraction. Self-hosts immediately.

1. lake build          # Rebuilds with Bootstrap.lean theorems
2. lake exe pseudoc    # Now dispatches to verified BootstrappedCompiler
   test.pseudo

---

## Overview


## ðŸŒ Overview

This project implements a **semantics-verified pseudocode compiler** written in **Lean 4**, designed to decouple *surface parsing* from *semantic interpretation*. Its long-term goal is to provide a **Universal Intermediate Representation (UniversalIR)** capable of capturing the structure and meaning of pseudocode written in multiple grammar styles.

Lean 4 is used not for convenience, but for rigor. The project uses Leanâ€™s dependent type theory to prove **semantic correctness** of parsing and evaluation â€” bridging human-readable pseudocode and verifiable execution.

---

## ðŸ§  Philosophy

Traditional compilers blend parsing, semantics, and execution, making verification difficult.  
This compiler instead emphasizes **separation of concerns**:

1. **Parsing**: Surface grammar â†’ abstract syntax tree (AST)  
2. **Normalization**: AST â†’ UniversalIR (canonical form independent of grammar)  
3. **Denotation**: AST â†’ mathematical meaning (`âŸ¦StmtâŸ§ : State â†’ State`)  
4. **Verification**: Lean-proof theorems guarantee composability and preservation  
5. **Execution**: Lean-generated code â†’ VM â†’ native machine code

This approach enables **multi-grammar pseudocode compilation** and **semantic-level proofs** of correctness, several research questions that can be answered around grammar-agnostic termination (see at the end) However I believe the biggest justification is to for students to learn as well as to increase the accuracy of code generated by AI tools that are increasingly writing pseudocode.

## âš™ï¸ Pipeline

Pseudocode
â†“
UniversalParser.lean
â†“
UniversalIR (AST + Semantics)
â†“
Lean Semantic Evaluation / Proofs
â†“
ToLean Codegen (Lean functions)
â†“
Lean VM / LLVM Compilation â†’ Native Execution

---

## ðŸ“‘ Example

### Input: `test.pseudo`

set x := 5;
while x > 0 do
print x;
set x := x - 1;
end


### Intermediate Representation (AST)

def progAST :=
[ Stmt.While (Expr.BinOp ">" (Expr.Var "x") (Expr.Num 0))
[ Stmt.Print (Expr.Var "x")
, Stmt.Set "x" (Expr.BinOp "-" (Expr.Var "x") (Expr.Num 1)) ] ]


### Denotational Semantics in Lean

abbrev State := String â†’ Option Nat

def evalExpr : Expr â†’ State â†’ Nat
| Expr.Num n, _ => n
| Expr.Var v, s => s v |>.getD 0
| Expr.BinOp "+" e1 e2, s => evalExpr e1 s + evalExpr e2 s
| Expr.BinOp "-" e1 e2, s => evalExpr e1 s - evalExpr e2 s
| Expr.BinOp ">" e1 e2, s => if evalExpr e1 s > evalExpr e2 s then 1 else 0
| _, _ => 0

def evalStmt : Stmt â†’ State â†’ State
| .Set x e, s => fun v => if v = x then some (evalExpr e s) else s v
| .Print e, s => (IO.println (evalExpr e s); s)
| .While cond body, s =>
if evalExpr cond s == 1 then
evalStmt (.While cond body) (evalProgram body s)
else s


### Example theorem (proof-friendly semantics)

theorem seq_compositional :
âŸ¦Sâ‚ ; Sâ‚‚âŸ§ = âŸ¦Sâ‚âŸ§ âˆ˜ âŸ¦Sâ‚‚âŸ§


This expresses **compositional semantics** â€” complex statements are mathematically reducible to smaller sub-statements enabling evaluation to an UniversalIR that dispatches to an intermediate IR where the denotational semantics with provable properties.

---

## ðŸ§© Architecture

Ast/
â”œâ”€â”€ Base.lean # Core IR interface
â””â”€â”€ UniversalIR.lean # AST definitions + semantics

Parser/
â””â”€â”€ UniversalParser.lean # Grammar-agnostic pseudocode parser

Codegen/
â””â”€â”€ ToLean.lean # Lean function code generation

Proofs/
â””â”€â”€ Semantics.lean # Denotational theorems and proofs used for boostrapping via autoformalization (generate the verified compiler)

Main.lean
lakefile.lean


---

## ðŸ§¬ Denotational Semantics and Verification

We define evaluation as a **valuation function** over typed syntactic structures:

\[
âŸ¦StmtâŸ§ : State â†’ State
\quad\text{and}\quad
âŸ¦ExprâŸ§ : State â†’ Value
\]

By defining semantics directly over UniversalIR, the system supports:
- Multi-grammar input equivalence proofs  
- Referential transparency via recursion over ASTs  
- Composability and algebraic reasoning over programs

**Goal:** Formalize proofs of termination, correctness, and compositionality.

---

## ðŸ§® Why This Is Hard (and Worth It)

| Challenge | Traditional Compiler | Lean/UniversalIR Approach |
|------------|----------------------|----------------------------|
| Syntax Variability | Brittle parsing | Grammar-agnostic IR |
| Semantic Proofs | Ad hoc testing | Formal theorems in Lean |
| Flexibility vs. Rigor | Trade-off | Decoupled via UniversalIR |
| Execution Model | Hidden runtime | Explicit verified VM semantics |

A true pseudocode compiler must generalize across human syntaxes while preserving formal meaning.  
UniversalIR solves this by providing a *shared semantic domain* for all grammars â€” a necessary foundation for verified interpretation, translation, and optimization.

---

## ðŸ§  Research Goals

1. Prove **preservation theorems**: parsing â†’ evaluation â†’ codegen equivalence.
2. Demonstrate verified execution equivalence across grammars.
3. Extend UniversalIR with **typed expression layers**.
4. Define a micro **bytecode VM** and prove evaluation equivalence between denotation and execution.

---

## â± Development Roadmap

| Week | Milestone |
|------|------------|
| 1 | Parser + UniversalIR + Main (âœ… done) |
| 2 | Full `if`/`while` parsing |
| 3 | Type checker + VerifiedIR |
| 4 | Error recovery + symbol tables |
| 5 | C/JS backend codegen |
| 6 | Formal proofs + test suite |
| 7 | Boostrap pseudo code compiler using autoformalization via theorem notebook|
---

## ðŸ§© Example Theorems (in progress)

theorem assign_correct :
âŸ¦assign x eâŸ§ s x = some (âŸ¦eâŸ§ s)

theorem seq_compositional :
âŸ¦S1; S2âŸ§ = âŸ¦S1âŸ§ âˆ˜ âŸ¦S2âŸ§

These form the basis for semantic soundness and program equivalence proofs.

---

## ðŸ”§ Build & Run

lake build
lake exe pseudoC test.pseudo


Expected: Prints countdown 5 â†’ 1 and outputs generated Lean 4 code equivalent to the pseudocode.

---

## ðŸ§© Future Work

- **Verified bytecode VM** with denotational equivalence proof  
- Multi-language frontends (C-style, Pythonic pseudocode)  
- Functional transformations verified by Lean tactics (`simp`, `rw`)  
- Type refinement and optimization proofs

---

## ðŸ§¾ References

- Winskel, *The Formal Semantics of Programming Languages*  
- Harper, *Practical Foundations for Programming Languages*  
- Chomsky, *Aspects of the Theory of Syntax*  
- Lean Prover Documentation (https://leanprover.github.io/)

---

## ðŸ§‘â€ðŸ’» Contributors

- Core developer â€” *LydiaQ*  
- Proofs & semantics â€” *coming soon, done in jupyter notebook to start* 
- Design philosophy inspired by **Chomsky's Universal Grammar + Verified Compilation**

---

## Multi-paradigm programming

A universal pseudocode compiler enables **adaptive multi-paradigm programming**, dynamically switching computation styles (e.g., imperative to functional, or even supporting other paradigms that have yet to emerge) mid-algorithm based on runtime conditionsâ€”impossible in rigid languages like Python or Haskell. For example, `SORT array IMPERATIVELY then MAP functionally` mutates small data like C++ before scaling to parallel map/reduce like Lisp; or, if we imagine something that may not be practical today but will be in the future for example,`SEARCH database QUANTUM else BRUTE_FORCE classically` leverages superposition with classical fallback. This kind of mixed-paradigm approach would be extremely difficult in classical languages. This abstracts "how" to compute via universal grammar, overcoming paradigm lock-in and enabling self-optimizing algorithms across von Neumann, dataflow, logical, and hybrid AI models.


---


## ðŸ§  Grammar-Agnostic Termination (Core justification for pseudoC)

**What it means**: Prove evaluation halts for *any* valid pseudocode regardless of surface syntax (C-style, Pythonic, ad-hoc), by normalizing to UniversalIR first.

**Why a pseudocode compiler?**:
- Traditional compilers are brittle, tied to fixed context-free grammars (CFGs): `stmt ::= while '(' expr ')' stmt` 
- UniversalIR decouples syntax variability â†’ proves termination over semantic structure alone
- **Chomsky Hierarchy Integration**: Encodes Type-1/2 grammars into dependent types, proving PTIME termination for practical pseudocode subsets 

**Halting Problem Connection**: 
- Skirts undecidability via *verifiably terminating subsets* (well-founded recursion, explicit decrements like `while x > 0`)
- Theorem target: `âˆ€ grammar, wellformed(pseudo) â†’ terminates(eval(IR(pseudo)))` 

## ðŸ”¬ Research Acceleration

| Goal | UniversalIR Breakthrough |
|------|-------------------------|
| **Termination Proofs** | Grammar-agnostic halting for Chomsky Type-1/2 â†’ beyond CompCertOC |
| **Complexity Theory** | Rank pseudocode decidability classes (PTIME/EXPTIME) via IR ranking  |


## ðŸ§® License

MIT License.  
Â© 2025.  
Distributed under the MIT License; see `LICENSE` for details.
